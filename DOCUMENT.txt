· DOCUMENT 

    · BROWSER ENVIRONMENT, SPECS - Everything that can run js is called a "host environment" either be it a browser, server, ... .
      A host environment provides its own objects and functions in additions to the language core.
        · DOM(DOCUMENT MODEL OBJECT) - The DOM represents all the page content as objects that can be modified.
          The "document" object is the main entry point to the page, we change or create anything regarding the page using it:
                document.body.style.background = "red"; //changes background color to red 
                setTimeout(() => document.body.style.background = "", 1000 ) // changes it back after 1 sec
            · DOM can be used for server-side scripts as well (not only browsers)
            · CSSOM is used together with DOM to modify CSS rules from js
        · BOM(BROWSER OBJECT MODEL) - The BOM represents additional objects provided by the host environment for working with everything except the document. For instance:
            - The "navigator" object provides background information about the browser and the os
            - The "location" object allows us to read the current URL and can redirect the browser to a new one. For example:
                    alert(location.href); //shows current URL 
                    if(confirm("Go to Wikipedia?")){
                        location.href = "https://wikipedia.org";
                    }
    
    · DOM TREE - The backbone of an HTML document is tags. According to DOM, every tag is an object. These objects are accessible using js and through them we can 
      modify a page. For example, document.body is an object reprenting the <body> tag:
            document.body.syle.background = 'red'; // the background of body is now red colored
        · Tags are "element nodes" and they form a tree structure.
        · The text inside the elements forms "text nodes" labelled as #text. Text nodes may only contain a string, they are always the leaf of a tree and thus cannot have children
        · AUTOCORRECTION - If the browser encouters a malfourmed HTML, it corrects it automatically when making the DOM. For instance, the top tag is always
          <html>, even if it doesn't exisat in the document, it will exist in the DOM because the browser will create it, same thing for <body>.
          Same thing for unclosed tags. Also, even though you can omit it when writing the document, tables must have the <tbody> tag, it is thus added automatically.
        · Comments are a node type and they're labelled as #comment as well as <!DOCTYPE...> . Everything inside an HTML document is part of DOM.
        · There are 12 node types but in practice we usually work with 4 of them:
          - "document" -> The entry point into DOM 
          - "element nodes" -> HTML-tags, the tree building blocks
          - "text nodes" -> Contain text
          - "comments" 

    · WALKING THE DOM - All operations on the DOM start with the "document" object throgh which we can reach every element.
        · ONTOP - The topmost tree nodes are available directly as "document" properties:
            - "document.documentELement" -> The DOM node of the <html> tag, the topmost one.
            - "document.body" -> The DOM node of the <body> tag .
            - "document.head" -> The DOM node of the <head> tag.
                · A script cannot access an element that doesn't exist at the moment of running(if you're inside <head>, you can't access <body>):
                        <head>
                            <script> alert(document.body); </script> // null, there's no <body> tag 
                        </head>
                        <body>
                            <script> alert(document.body); </script> // HTMLBodyElement 
                        </body>
                    · In DOM, null means "doesn't exist" or "no such code" 
        · CHILDREN - 
            - "Child nodes"(or children) -> Elements that are direct children. For instance <head> and <body> are children of <html>.
                    <html>
                    <body>
                        <div>Begin</div>
                        <ul>
                            <li>
                            </li>
                        </ul>
                · Here <div> and <ul> are children of <body> 
            - "Descendants" -> All elements that are nested in the given one, including children, their children and so on. In the above case, <div>, <ul> and <li>
               are descendants of <body>
            · "childNodes" -> The "childNodes" collection lists all child nodes, including text nodes:
                    <html>
                        <body>
                            <div>Begin</div>
                            <ul>
                                <li>information</li>
                            </ul>
                            <div>End</div>
                            <script>
                                for(let i = 0; i < document.body.childNodes.length; i++){
                                    alert(document.body.childNodes[i]); //Text, DIV, Text, ..., SCRIPT 
                                }
                            </script>
                        </body>
                    </html>
                · firstChild gives access to the first child, lastChild to the last one.
                · elem.hasChildNodes() -> Checks wether there are any children nodes 
        · DOM COLLECTIONS - "childNodes" is a Collection, an array-like iterable. We can thus use for..of on it and we can create an Array with it (Array.from(iterable))
            · All of these collections are Read-only
            · Almost all DOM collections are live(they reflect the current state of DOM)
        · SIBILINGS AND PARENT - Sibilings are child nodes of the same parent node:
                <html>
                    <head>...</head><body>...</body>
                </html>
            · Here, <head> and <body> are sibilings, <body> is the "next" or "right" of <head>; <heas> is the "previous" or "left" of <body>.
              We can access the next or previous sibing using "nextSibiling" or "previousSibiling" properties. The parent is available as "parentNode"
        · ELEMENT-ONLY NAVIGATION - In the navigation properties listed above we can see both text nodes, element nodes and even comment nodes but for many taks we don't 
          wanna see text and comment nodes, so we use these to see only the element nodes:
                - "children" -> Only those children that are element nodes 
                - "firstElementChild", "lastElementChild" -> First and last element children 
                - "previuosElementSibiling", "nextElementSibiling" -> Neighbouring elements
                - "parentElement" -> Parent element(returns the same as parentNode except for this exception:)
                        document.documentElement.parentNode; //document
                        document.documentElement.parentElement; //null
                    · This is because the root node (<html>) has "document" as its parent but "document" isn't an element node 
        · TABLES - Certain type of DOM may provide additional properties specific to their type, for example, <table>:
            - table.rows -> The collection of <tr> elements of the table 
            - table.caption/tHead/tFoot -> References to elements <caption>, <thead>, <tfoot>
            - table.tBodies -> The collection of <tbody> elements(according to the standard, there has to be at least 1 element(if not present, it is added by the browser))
            - [tBody/tHead/tFoot].rows -> The collection of <tr> inside the element
            - tr.cells -> The collection of <td> and <th> cells inside the given <tr>
            - tr.sectionRowIndex -> The index of the given <tr> inside the enclosing <thead>/<tbody>/<tfoot>
            - [<td>/<th>].cellIndex -> The number of the cell inside the enclosing <tr>

    · SEARCHING IN A DOCUMENT
        · "document.getElementById" - If an element has an id attribute, we can get the element using "document.getElementById(id)":
                <div id="elem">
                    <div id="elem-content">Element</div>
                </div>
                <script>
                    let elem = document.getElementById("elem");
                    elem.style.backgroundColor = 'red';
                </script>
            · Using ids to access an element is considered bad practice when writing js code, it is good for some little inline scripts.
            · Ids must be unique, or else the engine will return one of the elements with the same id without a logic 
        · "querySelectorAll" - "elem.querySelectorAll(css)" returns all elements inside "elem" matching the given CSS selector:
                <ul>
                    <li>The</li>
                    <li>test</li>
                </ul>
                <ul>
                    <li>has</li>
                    <li>passed</li>
                </ul>
                <script>
                    let elements = document.querySelectorAll('ul > li:last-child');
                    for (let elem of elements) {
                        alert(elem.innerHTML); // "test", "passed"
                    }         
                </script>   
        · "querySelector" - Returns the first found element of "elem.querySelectorAll(css)", it is thus equivalent to: "elem.querySelectorAll(css)[0]"
        · "matches" - The "elem.matches(css)" method returns true if elem matches the css-selector, false otherwise.(Useful when we are iterating and we only need one kind of element)
                <a href="https://something.zip">
                <!--other links-->
                <script>
                    for(let elem of document.body.children){
                        if(elem.matches('a[href$="zip"]')){
                            alert("The archive reference" + elem.href);
                        }
                    }
                </script>
        · "closest" - "elem.closest(css)" looks for the nearest ancestor that matches the CSS-selector. The "elem" itself is also included in the research
        · LIVE COLLECTIONS - All methods "getElementsBy[TagName/ClassName/Name]"(legacy) return a live collection. Such connections auto-update when the element 
          changes whereas querySelectorAll returns a static collection:
                <div>First div</div>
                <script>
                    let divs = document.getElementsByTagName('div');
                    let divs2 = document.querySelectorAll('div');
                    alert(divs.length); //1
                    alert(divs2.length); //1
                </script>
                <div>Second div</div>
                <script>
                    alert(divs.length); //2
                    alert(divs2.length); //1
                </script> 

    · NODE PROPERTIES: TYPE, TAG AND CONTENTS
        · DOM NODE CLASS - Different DOM nodes may have different properties(<a> is different from <input>). However, there are also properties and methods
          shared by all off them because all classes of DOM nodes form a single hierarcy. Each DOM node belongs to the corresponding built-in class, which are:
            - EventTarget -> The "root" abstract class for everything(serves as a base, so that all DOM nodes can support "events")
            - Node -> Base for DOM nodes, it is an abstract class (a class from which objects are not created)
            - Document -> A document as a whole, usually inherited by HTMLDocument(the document global object belongs to this class, serves as entry point into the DOM)
            - CharacterDatra -> An abstract class inherited by:
                - Text -> Class for text inside elements, ex: Hello in <p>Hello</p>
                - Comment -> Class for comments 
            - Element -> The base class for DOM elements, provides navigation and searching methods and it is used as a base for more specific classes
            - HTMLElement -> The base class for all HTML elements; it is inherited by concrete HTML elements:
                - HTMLInputElement -> The class for <input> elements
                - HTMLBodyElement -> The class for <body> elements
                - ...and so on
            · If, for example, we wanted to trace back <input> chain of inheritance, it would be:
                - HTMLInputElement -> Provides input specific properties
                - HTMLElement -> Provides common HTML element methods(and getters/setters)
                - Element -> Provides generic element methods
                - Node -> Provies common DOM node properties
                - EventTarget -> Gives the support for events
                - Object -> It all inherits from this, so, methods like hasOwnProperty are also available
            · As you can see above, nodes are just js objects that use prototype-based classes for inheritance          
        · "console.log(elem)" is equivalent in plain js to "console.dir(elem)", however if used in the browser console, the first shows the element DOM tree 
          while the second one shows the element as a DOM object 
        · THE "nodeType" PROPERTY - "elem.nodeType" returns a numeric value based on the type of the node 
            - elem.nodeType == 1 -> Element nodes 
            - elem.nodeType == 3 -> Text nodes 
            - elem.nodeType == 9 -> The Document object
            - ...look the specification (https://dom.spec.whatwg.org/#node)
          Can be used instead of "instanceof" 
        · TAG: "nodeName" AND "tagName" -> Given a DOM node, we can read its tag name using "nodeName" or "tagName":
                document.body.nodeName; //BODY
                document.body.tagName;  //BODY
            · There is a subtle difference between the 2:
                - "tagName" exists only for "Element" nodes 
                - "nodeName" is defined for any "Node":
                    - for elements, it's the same as tagName 
                    - for other nodes (text,comment, etc) it has a string with the node type 
        · "innerHTML": THE CONTENTS - The "elem.innerHTML" property allows to get the HTML inside the "elem" as a string. We can also use this property to modify 
          the html script:
                <body>
                    <div> A div</div>
                    <script>
                        alert(document.body.innerHTML);  // shows the <div> and the <script>
                        document.body.innerHTML = "<p>Now it's gone</p>";
                    </script>
                </body>
            · We can also write scripts in innerHTML and make them become part of the page, however they won't execute 
            · Even though you may think "elem.innerHTML += something" adds "something" to the html document, it doesn't, it overwrites the previous document with "something". It is thus equivalent to: "elem.body.innerHTML = something"
        · FULL HTML OF THE ELEMENT - The "elem.outerHTML" contains the full HTML of the element, just like innerHTML plus the element itself:
                <div id="elem">Hello<b>World</b></div>
                <script>
                    alert(elem.outerHTML); //  <div id="elem">Hello<b>World</b></div>
                </script> 
            · When modifying an HTML piece using outerHTML, the element is not changed, instead, it is replaced. That is: The new lines go in its place, however, 
              references to that element are not deleted and thus is still accessible:
                    <div> Hello </div>
                    <script>
                        let div = document.querySelector('div'); 
                        div.outerHTML = '<p>Different stuff</p>';
                        alert(div.outerHTML); //  <div> Hello </div> -> Still an accessible reference 
                    </script>
        · TEXT NODE CONTENT - "innerHTML" is ONLY valid for element nodes, other types (text, comments) have their counterpart: nodeValue and data which are almost the same:
                <body>
                    Hello
                    <!-- Comment -->
                    <script>
                        let text = document.body.firstChild;
                        alert(text.data); //Hello
                        let comment = text.nextSibiling;
                        alert(comment.data); //Comment
                    </script>
                </body>
        · PURE TEXT - The "textContent" provides access to the text inside the element minus all the <tags>:(literally innerHTML without the tags)
            · Can be used to insert strings exclusively as every character is treated as a literal.
        · THE "hidden" PROPERTY - The "hidden" attribute specifies wether an element is visible or not(same as style="display:none"):
                <div id="elem"> A blinking element</div>
                <script>
                    setInterval(() => elem.hidden = !elem.hidden, 1000)
                </script>
        · MORE PROPERTIES - DOM elements have so many more properties which can be found in the specification, for instance:
            - "value" -> The value for <input>, <select> and <textarea>
            - "href" -> The href for <a href="...">
            - "id" -> The value of "id" attribute for all elements
            - and so much more in the next episode of "I have to read so many manuals". See ya!

    · ATTRIBUTES AND PROPERTIES - When the browser loads the page, it parses(reads) the HTML and generates DOM objects from it. For elements nodes, most standard
      HTML attributes become properties of DOM objects, for instance, if the tag is "<body id="page">" then the DOM objet has body.id="page".
        · DOM PROPERTIES - DOM nodes are regular js objects, we can alter them:
                document.body.myData = {
                    name: "Caeser",
                    title: "Imperator"
                };
                document.body.myData.title; //Imperator
            · We can add methods as well:
                    document.body.sayTagName = function(){
                        alert(this.tagName);
                    };
                    document.body.sayTagName(); //BODY
        · HTML ATTRIBUTES - In HTML, tags may have attributes. When the browser parses the HTML to create DOM objects for tags, it recogizes standard 
          attributes and creates DOM properties from them. This means that this thing happens for "standard attributes" not custom ones:
                <body id="test" something="non-standard">
                    <script>
                        alert(document.body.id); //test 
                        alert(document.body.something); //undefined 
                    </script>
                </body>
            · Note that a standard attribute for an element can be unknown for another one("type" is standard for <input> but not for <body>).
            · In order to access non-standard attributes, we use the following methods:
                · elem.hasAttribute(name) -> Checks for attribute existance  
                · elem.getAttribute(name) -> Gets the value
                · elem.setAttribute(name, value) -> Sets the value 
                · elem.removeAttribute(name) -> Removes the attribute 
                        <body something="non-standard">
                            <script> 
                                alert(document.body.getAttribute(something)); //non-standard
                            </script>
                        </body>
            · HTML attributes have the following features:
                - Their name is case insesitive (id == ID)
                - Their values are always strings (elem.setAttribute('Attr', 123); // -> the value of attr is "123")
                - "elemName.attribute" returns an iterable collection of all the attributes 
                · PROPERTY ATTRIBUTE SYNCHRONIZATION - When a standard attribute changes, the corresponding property is auto-updated and (with some exceptions) vice-versa:
                        <input>
                        <script>
                            let input = document.querySelector('input');
                            input.setAttribute('id', 'id');       // -> attribute => property
                            input.setAttribute('value', 'text');  // -> attribute => property
                            alert(input.id + ", " + input.value); //id, text
                            input.value = 'newValue';
                            input.id = 'newId';
                            alert(input.getAttribute('id')); //newId -> (property => attribute)
                            alert(input.getAttribute('value')); //text -> It didn't change ( property !=> attribute)  
                        </script>
        · DOM PROPERTIES ARE TYPED - DOM properties are not always strings, for instance checkboxes are booleans 
        · NON STANDARD ATTRIBUTES, DATASET - Sometimes, non-standard attributes are used to pass custom data from HTML to js or to "mark" HTML elements for js:
                <div show-info="name"></div>
                <!-- and age here -->
                <div show-info="age"></div>
                    <script>
                    // the code finds an element with the mark and shows what's requested
                    let user = {
                        name: "Pete",
                        age: 25
                    };
                    for(let div of document.querySelectorAll('[show-info]')) {
                        // insert the corresponding info into the field
                        let field = div.getAttribute('show-info');
                        div.innerHTML = user[field]; // first Pete into "name", then 25 into "age"
                    }
                    </script>
            · Being marked, they can be used for styling puroposes for a process that has several phases, each one with a different style, color, ...
            · Since HTML is an alive language, the custom keywords we used could be in the future be used for a standard attribute that does something different. 
              For this reason we have "data-" attributes: all elements starting with "data-" are reserved for programmer use. They are available in the "dataset" property, 
              for example, if an "elem" has an attribute named "data-about" is available as "elem.dataset.about":
                    <body data-about="Elephants">
                    <script>
                        alert(doucment.body.dataset.about); //Elephants
                    </script>
                · Multiword attributes like "data-order-state" become camel cased : "dataset.orderState"
                
